"use client";

import * as React from "react";
import { useParams } from "next/navigation";
import { useSession } from "next-auth/react";
import useSWR from "swr";
import { NotificationContext } from "@/context/NotificationContext";
import { Box, Stack, Typography, CircularProgress, Alert } from "@mui/material";
import IncidentDetailsCard from "@/components/IncidentDetailsCard";
import IncidentAuditTrail from "@/components/IncidentAuditTrail";
import IncidentActionForm from "@/components/IncidentActionForm";
import ResolutionDialog from "@/components/ResolutionDialog";
import Button from "@mui/material/Button";
import ResetPasswordModal from "@/components/ResetPasswordModal";

const fetcher = (url) => fetch(url).then((res) => res.json());

const updateIncidentAPI = async (id, data) => {
  const response = await fetch(`/api/incidents/${id}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data),
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || "Failed to update incident");
  }
  return response.json();
};

const editCommentAPI = async (id, entryId, newComment) => {
  const response = await fetch(`/api/incidents/${id}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ action: "editAuditComment", entryId, newComment }),
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || "Failed to edit comment");
  }
  return response.json();
};

export default function IncidentDetailsPage() {
  const params = useParams();
  const { showNotification } = React.useContext(NotificationContext);
  const { data: session } = useSession();
  const user = session?.user;
  const {
    data: incidentData,
    error,
    isLoading,
    mutate,
  } = useSWR(params.id ? `/api/incidents/${params.id}` : null, fetcher, {
    refreshInterval:
      user?.role === "admin" || user?.role === "sys_admin" ? 15000 : 0,
    revalidateOnFocus: !(user?.role === "admin" || user?.role === "sys_admin"),
  });

  const incident = incidentData;
  //console.log("Full Incident Object:", incident);

  const [isDialogOpen, setDialogOpen] = React.useState(false);
  const [isResetModalOpen, setIsResetModalOpen] = React.useState(false);
  const [isOptimisticallyResolved, setOptimisticallyResolved] =
    React.useState(false); // <-- ADD THIS LINE

  const auditTrailRef = React.useRef(null);
  const [isAuditTrailExpanded, setIsAuditTrailExpanded] = React.useState(false);

  const handlePasswordResetSuccess = () => {
    setIsResetModalOpen(false); // This closes the modal
    mutate(); // This re-fetches all the incident data
    showNotification(
      "ESS Password has been reset successfully. User will be notified via email.",
      "success"
    );
  };

  React.useEffect(() => {
    setTimeout(() => {
      auditTrailRef.current?.scrollToBottom();
    }, 0);
  }, [incident?.auditTrail?.length]);

  const handleUpdate = async (updateData) => {
  // Immediately exit if the comment is empty
  if (!updateData.comment || !updateData.comment.trim()) return;

  const payload = { ...updateData };
  if (incident?.status === "New") {
    payload.status = "Processed";
  }

  // --- SIMPLIFIED OPTIMISTIC UI LOGIC ---

  // 1. Create a temporary audit entry for instant display in the UI.
  //    We use a simple random ID that is ONLY for React's internal list rendering.
  //    The real, permanent ID will be generated by the database.
  const optimisticAuditEntry = {
    id: 'optimistic-' + Math.random(), 
    author: user.name,
    action: "Action Taken",
    comment: updateData.comment,
    timestamp: new Date().toISOString(), // Use the current time for instant display
  };

  // 2. Instantly update the UI with the temporary data
  mutate(
    (currentData) => ({
      ...currentData,
      status: payload.status || currentData.status,
      auditTrail: [...currentData.auditTrail, optimisticAuditEntry],
    }),
    false // Tell SWR not to re-fetch from the server immediately
  );

  // Instantly scroll the audit trail to the bottom
  setTimeout(() => auditTrailRef.current?.scrollToBottom(), 0);

  // 3. Send the real request to the server in the background.
  //    Notice we are NOT sending the temporary ID.
  try {
    await updateIncidentAPI(params.id, payload);

    // After the server succeeds, we run mutate() again without arguments.
    // This re-fetches the real data from the server, which will seamlessly
    // replace the temporary entry with the permanent one from the database.
    mutate();

  } catch (err) {
    showNotification(err.message, "error");
    // If the server fails, revert the UI to the original state
    mutate();
  }
};

  const handleConfirmResolve = async (resolutionData) => {
    setOptimisticallyResolved(true);
    try {
      await updateIncidentAPI(params.id, {
        ...resolutionData,
        status: resolutionData.action === "close" ? "Closed" : "Resolved",
      });
      showNotification(
        `Incident ${
          resolutionData.action === "close" ? "Closed" : "Resolved"
        } successfully.`,
        "success"
      );
      mutate(); // Re-fetch data
    } catch (err) {
      setOptimisticallyResolved(false); // Revert optimistic state on error
      showNotification(err.message, "error");
    }
  };

  const handleCommentEdit = async (entryId, newComment) => {
    if (!incident) return;
    try {
      await editCommentAPI(incident.id, entryId, newComment);
      mutate(); // Re-fetch data
    } catch (err) {
      showNotification(err.message, "error");
    }
  };

  if (!user) return null;
  if (isLoading) {
    return (
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: "calc(100vh - 200px)",
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ m: 4 }}>
        Failed to load incident details.
      </Alert>
    );
  }

  if (!incident) {
    return (
      <Box sx={{ textAlign: "center", mt: 10 }}>
        <Typography variant="h4" color="error">
          Incident Not Found
        </Typography>
        <Typography>
          The incident with ID "{params.id}" could not be found.
        </Typography>
      </Box>
    );
  }

  const isResolved =
    incident.status === "Resolved" ||
    incident.status === "Closed" ||
    isOptimisticallyResolved;

  const canTakeAction =
    (user.role === "admin" ||
      user.role === "sys_admin" ||
      user.role === "network_vendor" ||
      user.role === "biometric_vendor") &&
    !isResolved;

  // First, check if a password reset has already occurred.
  const isPasswordReset = incident.auditTrail.some(
    (entry) => entry.action === "Password Reset"
  );

  // Now, decide if the button should be shown.
  const showResetButton =
    canTakeAction &&
    incident?.incidentType?.name.toLowerCase() === "ess password" &&
    incident?.status !== "New" &&
    !isPasswordReset;

  return (
    <>
      <Box
        sx={{
          display: "flex",
          gap: 3,
          alignItems: "stretch",
          height: "calc(100vh - 112px)",
        }}
      >
        <Box sx={{ flex: 7, minWidth: 0 }}>
          <IncidentDetailsCard incident={incident} />
        </Box>
        {canTakeAction ? (
          <Stack
            spacing={0}
            sx={{ flex: 5, minWidth: 0, position: "relative" }}
          >
            <Box
              sx={{
                flexGrow: 1,
                minHeight: 0,
                display: "flex",
                position: "relative",
                zIndex: 2,
              }}
            >
              <IncidentAuditTrail
                ref={auditTrailRef}
                auditTrail={incident.auditTrail || []}
                incident={incident}
                isResolved={isResolved}
                onCommentEdit={handleCommentEdit}
                isExpanded={isAuditTrailExpanded}
                onToggleExpand={() => setIsAuditTrailExpanded((prev) => !prev)}
              />
            </Box>

            {!isAuditTrailExpanded && (
              <IncidentActionForm
                incident={incident}
                onUpdate={handleUpdate}
                onOpenResolveDialog={() => setDialogOpen(true)}
                showResetButton={showResetButton}
                onOpenResetDialog={() => setIsResetModalOpen(true)}
              />
            )}
          </Stack>
        ) : (
          <Box sx={{ flex: 5, minWidth: 0, display: "flex" }}>
            <IncidentAuditTrail
              ref={auditTrailRef}
              auditTrail={incident.auditTrail || []}
              incident={incident}
              isResolved={isResolved}
              onCommentEdit={handleCommentEdit}
              isExpanded={false}
              onToggleExpand={() => {}}
            />
          </Box>
        )}
      </Box>
      <ResolutionDialog
        open={isDialogOpen}
        onClose={() => setDialogOpen(false)}
        onConfirm={handleConfirmResolve}
      />
      <ResetPasswordModal
        open={isResetModalOpen}
        onClose={() => setIsResetModalOpen(false)}
        incident={incident}
        onSuccess={handlePasswordResetSuccess}
      />
    </>
  );
}
